local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")

local insert, remove = table.insert, table.remove
local format = string.format
local newInstance = Instance.new

-- Allowed left-only positions with AnchorPoints for perfect alignment
local notificationPositions = {
    -- Positioned slightly outside the exact corner to "hug" top-left screen corner better
    ["TopLeft"] = {Position = UDim2.new(0, -2, 0, -2), AnchorPoint = Vector2.new(0, 0)},
    ["MiddleLeft"] = {Position = UDim2.new(0, -2, 0.5, 0), AnchorPoint = Vector2.new(0, 0.5)},
    ["BottomLeft"] = {Position = UDim2.new(0, -2, 1, 2), AnchorPoint = Vector2.new(0, 1)},
}

local function isTopPosition(position)
    return position == "TopLeft" or position == "MiddleLeft"
end

local function isBottomPosition(position)
    return position == "BottomLeft"
end

local function protectScreenGui(screenGui)
    if syn and syn.protect_gui then
        syn.protect_gui(screenGui)
        screenGui.Parent = CoreGui
    elseif gethui then
        screenGui.Parent = gethui()
    else
        screenGui.Parent = CoreGui
    end
end

local function createObject(className, properties)
    local instance = newInstance(className)
    for index, value in pairs(properties) do
        instance[index] = value
    end
    return instance
end

local function fadeAndSlideOut(notification, onComplete)
    local goal = {
        TextTransparency = 1,
        TextStrokeTransparency = 1,
        Position = notification.Position + UDim2.new(-0.1, 0, 0, 0) -- slide left on fade out
    }
    local tween = TweenService:Create(notification, TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), goal)
    tween.Completed:Connect(onComplete)
    tween:Play()
end

local notifications = {}

do
    function notifications.new(settings)
        assert(settings, "missing argument #1 in function notifications.new(settings)")
        assert(typeof(settings) == "table", format("expected table for argument #1 in function notifications.new(settings), got %s", typeof(settings)))

        local notificationSettings = {ui = {notificationsFrame = nil}}
        for setting, value in pairs(settings) do
            notificationSettings[setting] = value
        end

        -- Defaults
        notificationSettings.NotificationPosition = notificationSettings.NotificationPosition or "TopLeft"
        notificationSettings.NotificationLifetime = notificationSettings.NotificationLifetime or 3
        notificationSettings.TextColor = notificationSettings.TextColor or Color3.new(1, 1, 1)
        notificationSettings.TextSize = notificationSettings.TextSize or 14
        notificationSettings.TextStrokeTransparency = notificationSettings.TextStrokeTransparency or 0.8
        notificationSettings.TextStrokeColor = notificationSettings.TextStrokeColor or Color3.new(0, 0, 0)
        notificationSettings.TextFont = notificationSettings.TextFont or Enum.Font.Code
        notificationSettings.BookmarkColor = notificationSettings.BookmarkColor or Color3.fromRGB(255, 85, 85)

        assert(notificationPositions[notificationSettings.NotificationPosition], "NotificationPosition must be TopLeft, MiddleLeft, or BottomLeft")

        setmetatable(notificationSettings, {__index = notifications})
        notificationSettings:BuildNotificationUI()
        notificationSettings._activeNotifications = {}

        return notificationSettings
    end

    function notifications:SetNotificationLifetime(number)
        assert(number, "missing argument #1 in function SetNotificationLifetime(number)")
        assert(typeof(number) == "number", format("expected number for argument #1 in function SetNotificationLifetime, got %s", typeof(number)))
        self.NotificationLifetime = number
    end

    function notifications:SetTextColor(color3)
        assert(color3, "missing argument #1 in function SetTextColor(Color3)")
        assert(typeof(color3) == "Color3", format("expected Color3 for argument #1 in function SetTextColor3, got %s", typeof(color3)))
        self.TextColor = color3
    end

    function notifications:SetTextSize(number)
        assert(number, "missing argument #1 in function SetTextSize(number)")
        assert(typeof(number) == "number", format("expected number for argument #1 in function SetTextSize, got %s", typeof(number)))
        self.TextSize = number
    end

    function notifications:SetTextStrokeTransparency(number)
        assert(number, "missing argument #1 in function SetTextStrokeTransparency(number)")
        assert(typeof(number) == "number", format("expected number for argument #1 in function SetTextStrokeTransparency, got %s", typeof(number)))
        self.TextStrokeTransparency = number
    end

    function notifications:SetTextStrokeColor(color3)
        assert(color3, "missing argument #1 in function SetTextStrokeColor(Color3)")
        assert(typeof(color3) == "Color3", format("expected Color3 for argument #1 in function SetTextStrokeColor, got %s", typeof(color3)))
        self.TextStrokeColor = color3
    end

    function notifications:SetTextFont(font)
        assert(font, "missing argument #1 in function SetTextFont(Font)")
        assert((typeof(font) == "string" or typeof(font) == "EnumItem"))
        if typeof(font) == "string" then
            self.TextFont = Enum.Font[font]
        else
            self.TextFont = font
        end
    end

    function notifications:SetBookmarkColor(color3)
        assert(color3, "missing argument #1 in function SetBookmarkColor(Color3)")
        assert(typeof(color3) == "Color3", format("expected Color3 for argument #1 in function SetBookmarkColor, got %s", typeof(color3)))
        self.BookmarkColor = color3
    end

    function notifications:SetNotificationPosition(position)
        assert(position, "missing argument #1 in function SetNotificationPosition(position)")
        assert(notificationPositions[position], "Position must be TopLeft, MiddleLeft, or BottomLeft")
        self.NotificationPosition = position
        if self.ui and self.ui.notificationsFrame then
            local posData = notificationPositions[position]
            self.ui.notificationsFrame.Position = posData.Position
            self.ui.notificationsFrame.AnchorPoint = posData.AnchorPoint
        end
    end

    function notifications:BuildNotificationUI()
        if notifications_screenGui then
            notifications_screenGui:Destroy()
        end

        getgenv().notifications_screenGui = createObject("ScreenGui", {
            ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
            IgnoreGuiInset = true,
        })
        protectScreenGui(notifications_screenGui)

        local posData = notificationPositions[self.NotificationPosition]

        self.ui.notificationsFrame = createObject("Frame", {
            Name = "notificationsFrame",
            Parent = notifications_screenGui,
            BackgroundColor3 = Color3.fromRGB(0, 0, 0),
            BackgroundTransparency = 1, -- make holder fully invisible now
            Position = posData.Position,
            AnchorPoint = posData.AnchorPoint,
            Size = UDim2.new(0, 120, 0, 260),
            ClipsDescendants = true
        })

        -- no UIListLayout for manual tween positioning
    end

    function notifications:_repositionNotifications()
        local spacing = 5
        local stackDown = isTopPosition(self.NotificationPosition)
        local yOffset = 0

        local notificationsToPosition = self._activeNotifications

        if not stackDown then
            local reversed = {}
            for i = #self._activeNotifications, 1, -1 do
                insert(reversed, self._activeNotifications[i])
            end
            notificationsToPosition = reversed
        end

        for _, notif in ipairs(notificationsToPosition) do
            local targetY
            if stackDown then
                targetY = yOffset
                yOffset = yOffset + notif.AbsoluteSize.Y + spacing
            else
                targetY = - (yOffset + notif.AbsoluteSize.Y)
                yOffset = yOffset + notif.AbsoluteSize.Y + spacing
            end

            local targetPosition = UDim2.new(0, 0, 0, targetY)
            local tween = TweenService:Create(notif, TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
                Position = targetPosition
            })
            tween:Play()
        end
    end

    function notifications:Notify(text)
        local notifFrame = createObject("Frame", {
            Name = "notification",
            Parent = self.ui.notificationsFrame,
            BackgroundColor3 = Color3.fromRGB(0, 0, 0),
            BackgroundTransparency = 0,
            Size = UDim2.new(0, 120, 0, 28),
            Position = UDim2.new(0, 0, 0, 0),
            ClipsDescendants = true,
        })

        local bookmark = createObject("Frame", {
            Name = "bookmark",
            Parent = notifFrame,
            BackgroundColor3 = self.BookmarkColor,
            Size = UDim2.new(0, 4, 1, 0),
            Position = UDim2.new(0, 0, 0, 0),
        })

        local label = createObject("TextLabel", {
            Name = "label",
            Parent = notifFrame,
            BackgroundTransparency = 1,
            Position = UDim2.new(0, 6, 0, 0),
            Size = UDim2.new(1, -6, 1, 0),
            Text = text,
            TextWrapped = true,
            TextXAlignment = Enum.TextXAlignment.Left,
            TextYAlignment = Enum.TextYAlignment.Center,
            Font = self.TextFont,
            TextColor3 = self.TextColor,
            TextSize = self.TextSize,
            TextStrokeColor3 = self.TextStrokeColor,
            TextStrokeTransparency = self.TextStrokeTransparency,
        })

        -- Animate slide-in from left (-0.2 x offset)
        notifFrame.Position = UDim2.new(-0.2, 0, 0, 0)
        label.TextTransparency = 1
        label.TextStrokeTransparency = 1

        local tweenIn = TweenService:Create(notifFrame, TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
            Position = UDim2.new(0, 0, 0, 0),
        })

        local textTween = TweenService:Create(label, TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
            TextTransparency = 0,
            TextStrokeTransparency = self.TextStrokeTransparency
        })

        tweenIn:Play()
        textTween:Play()

        insert(self._activeNotifications, notifFrame)
        self:_repositionNotifications()

        task.delay(self.NotificationLifetime, function()
            fadeAndSlideOut(notifFrame, function()
                for i, v in ipairs(self._activeNotifications) do
                    if v == notifFrame then
                        remove(self._activeNotifications, i)
                        break
                    end
                end
                notifFrame:Destroy()
                self:_repositionNotifications()
            end)
        end)
    end
end

return notifications
