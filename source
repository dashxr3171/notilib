-- variables
local TweenService, CoreGui = game:GetService("TweenService"), game:GetService("CoreGui")

local insert, remove = table.insert, table.remove
local format = string.format
local newInstance = Instance.new
local fromRGB = Color3.fromRGB

local notificationPositions = {
    ["Middle"] = UDim2.new(0.445, 0, 0.7, 0),
    ["MiddleRight"] = UDim2.new(0.85, 0, 0.7, 0),
    ["MiddleLeft"] = UDim2.new(0.01, 0, 0.7, 0),

    ["Top"] = UDim2.new(0.445, 0, 0.007, 0),
    ["TopLeft"] = UDim2.new(0.06, 0, 0.001, 0),
    ["TopRight"] = UDim2.new(0.8, 0, 0.001, 0),

    ["Bottom"] = UDim2.new(0.445, 0, 0.95, 0),
    ["BottomLeft"] = UDim2.new(0.06, 0, 0.95, 0),
    ["BottomRight"] = UDim2.new(0.8, 0, 0.95, 0),
}

-- Determines if the position is a top or bottom stacking area
local function isTopPosition(position)
    return position == "Top" or position == "TopLeft" or position == "TopRight" or
           position == "Middle" or position == "MiddleLeft" or position == "MiddleRight"
end

local function isRightSide(position)
    return position == "TopRight" or position == "MiddleRight" or position == "BottomRight"
end

local function isLeftSide(position)
    return position == "TopLeft" or position == "MiddleLeft" or position == "BottomLeft"
end

local function protectScreenGui(screenGui)
    if syn and syn.protect_gui then
        syn.protect_gui(screenGui)
        screenGui.Parent = CoreGui
    elseif gethui then
        screenGui.Parent = gethui()
    else
        screenGui.Parent = CoreGui
    end
end

local function createObject(className, properties)
    local instance = newInstance(className)
    for index, value in next, properties do
        instance[index] = value
    end
    return instance
end

local function fadeAndSlideOut(notification, isRight, onComplete)
    -- Tween slide out horizontally and fade text out
    local goal = {
        TextTransparency = 1,
        TextStrokeTransparency = 1,
        Position = notification.Position + UDim2.new(isRight and 0.1 or -0.1, 0, 0, 0)
    }
    local tween = TweenService:Create(notification, TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), goal)
    tween.Completed:Connect(onComplete)
    tween:Play()
end

local notifications = {}

do
    function notifications.new(settings)
        assert(settings, "missing argument #1 in function notifications.new(settings)")
        assert(typeof(settings) == "table", format("expected table for argument #1 in function notifications.new(settings), got %s", typeof(settings)))

        local notificationSettings = {ui = {notificationsFrame = nil, notificationsFrame_UIListLayout = nil}}

        for setting, value in next, settings do
            notificationSettings[setting] = value
        end

        -- Defaults
        notificationSettings.NotificationPosition = notificationSettings.NotificationPosition or "TopRight"
        notificationSettings.NotificationLifetime = notificationSettings.NotificationLifetime or 3
        notificationSettings.TextColor = notificationSettings.TextColor or Color3.new(1, 1, 1)
        notificationSettings.TextSize = notificationSettings.TextSize or 14
        notificationSettings.TextStrokeTransparency = notificationSettings.TextStrokeTransparency or 0.8
        notificationSettings.TextStrokeColor = notificationSettings.TextStrokeColor or Color3.new(0, 0, 0)
        notificationSettings.TextFont = notificationSettings.TextFont or Enum.Font.SourceSansBold

        setmetatable(notificationSettings, {__index = notifications})
        notificationSettings:BuildNotificationUI()
        notificationSettings._activeNotifications = {}

        return notificationSettings
    end

    function notifications:SetNotificationLifetime(number)
        assert(number, "missing argument #1 in function SetNotificationLifetime(number)")
        assert(typeof(number) == "number", format("expected number for argument #1 in function SetNotificationLifetime, got %s", typeof(number)))
        self.NotificationLifetime = number
    end

    function notifications:SetTextColor(color3)
        assert(color3, "missing argument #1 in function SetTextColor(Color3)")
        assert(typeof(color3) == "Color3", format("expected Color3 for argument #1 in function SetTextColor3, got %s", typeof(color3)))
        self.TextColor = color3
    end

    function notifications:SetTextSize(number)
        assert(number, "missing argument #1 in function SetTextSize(number)")
        assert(typeof(number) == "number", format("expected number for argument #1 in function SetTextSize, got %s", typeof(number)))
        self.TextSize = number
    end

    function notifications:SetTextStrokeTransparency(number)
        assert(number, "missing argument #1 in function SetTextStrokeTransparency(number)")
        assert(typeof(number) == "number", format("expected number for argument #1 in function SetTextStrokeTransparency, got %s", typeof(number)))
        self.TextStrokeTransparency = number
    end

    function notifications:SetTextStrokeColor(color3)
        assert(color3, "missing argument #1 in function SetTextStrokeColor(Color3)")
        assert(typeof(color3) == "Color3", format("expected Color3 for argument #1 in function SetTextStrokeColor, got %s", typeof(color3)))
        self.TextStrokeColor = color3
    end

    function notifications:SetTextFont(font)
        assert(font, "missing argument #1 in function SetTextFont(Font)")
        assert((typeof(font) == "string" or typeof(font) == "EnumItem"))
        if typeof(font) == "string" then
            self.TextFont = Enum.Font[font]
        else
            self.TextFont = font
        end
    end

    function notifications:SetNotificationPosition(position)
        assert(position, "missing argument #1 in function SetNotificationPosition(position)")
        assert(notificationPositions[position], format("Invalid notification position '%s'", tostring(position)))

        self.NotificationPosition = position
        if self.ui and self.ui.notificationsFrame then
            self.ui.notificationsFrame.Position = notificationPositions[position]
        end
    end

    function notifications:BuildNotificationUI()
        if notifications_screenGui then
            notifications_screenGui:Destroy()
        end

        getgenv().notifications_screenGui = createObject("ScreenGui", {
            ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        })
        protectScreenGui(notifications_screenGui)

        self.ui.notificationsFrame = createObject("Frame", {
            Name = "notificationsFrame",
            Parent = notifications_screenGui,
            BackgroundColor3 = Color3.fromRGB(255, 255, 255),
            BackgroundTransparency = 1.000,
            Position = notificationPositions[self.NotificationPosition],
            Size = UDim2.new(0, 240, 0, 215),
            ClipsDescendants = true
        })

        self.ui.notificationsFrame_UIListLayout = createObject("UIListLayout", {
            Name = "notificationsFrame_UIListLayout",
            Parent = self.ui.notificationsFrame,
            Padding = UDim.new(0, 4),
            SortOrder = Enum.SortOrder.LayoutOrder
        })

        -- We will disable automatic layout to manage tweening manually
        self.ui.notificationsFrame_UIListLayout.Parent = nil
    end

    function notifications:_repositionNotifications()
        -- Reposition all active notifications smoothly based on stacking rules
        local yOffset = 0
        local spacing = 4
        local stackDown = isTopPosition(self.NotificationPosition) -- true if stacking downward, false if upward

        -- For stacking up, we start from the bottom and move upwards
        local notificationsToPosition = self._activeNotifications

        if not stackDown then
            -- Reverse the order for stacking upward (bottom positions)
            notificationsToPosition = {}
            for i = #self._activeNotifications, 1, -1 do
                insert(notificationsToPosition, self._activeNotifications[i])
            end
        end

        for i, notif in ipairs(notificationsToPosition) do
            local targetY
            if stackDown then
                targetY = yOffset
                yOffset = yOffset + notif.AbsoluteSize.Y + spacing
            else
                -- Start from bottom, move up
                targetY = - (yOffset + notif.AbsoluteSize.Y)
                yOffset = yOffset + notif.AbsoluteSize.Y + spacing
            end

            local targetPosition = UDim2.new(0, 0, 0, targetY)
            local tween = TweenService:Create(notif, TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
                Position = targetPosition
            })
            tween:Play()
        end
    end

    function notifications:Notify(text)
        local notifFrame = createObject("TextLabel", {
            Name = "notification",
            Parent = self.ui.notificationsFrame,
            BackgroundColor3 = Color3.fromRGB(30, 30, 30),
            BackgroundTransparency = 0.3,
            Size = UDim2.new(0, 220, 0, 26),
            Text = text,
            TextWrapped = true,
            TextXAlignment = Enum.TextXAlignment.Left,
            TextYAlignment = Enum.TextYAlignment.Center,

            Font = self.TextFont,
            TextColor3 = self.TextColor,
            TextSize = self.TextSize,
            TextStrokeColor3 = self.TextStrokeColor,
            TextStrokeTransparency = self.TextStrokeTransparency,
            Position = UDim2.new(0, 0, 0, 0),
            ClipsDescendants = true,
            LayoutOrder = #self._activeNotifications + 1
        })

        -- Tween slide-in from the opposite side (left or right) based on position
        local isRight = isRightSide(self.NotificationPosition)
        local startX = isRight and 0.2 or -0.2
        notifFrame.Position = UDim2.new(startX, 0, 0, 0)
        notifFrame.TextTransparency = 1
        notifFrame.TextStrokeTransparency = 1

        local tweenIn = TweenService:Create(notifFrame, TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
            Position = UDim2.new(0, 0, 0, 0),
            TextTransparency = 0,
            TextStrokeTransparency = self.TextStrokeTransparency
        })
        tweenIn:Play()

        insert(self._activeNotifications, notifFrame)
        self:_repositionNotifications()

        -- Remove notification after lifetime with fade and slide out
        task.delay(self.NotificationLifetime, function()
            fadeAndSlideOut(notifFrame, isRight, function()
                -- Remove from active notifications
                for i, v in ipairs(self._activeNotifications) do
                    if v == notifFrame then
                        remove(self._activeNotifications, i)
                        break
                    end
                end
                notifFrame:Destroy()
                self:_repositionNotifications()
            end)
        end)
    end
end

return notifications
